"""Playground module for practicing adding type hints to
Python code.

You may assume that the functions in this module operate on
strings. Your type hints should be as generic as possible.

Disclaimer: This module was generated by https://claude.ai/.
"""

from collections.abc import Sequence, Collection
from typing import Iterable, List, TypeVar, Any
from numbers import Number
from abc import ABCMeta, abstractmethod


def reverse_string(s: Sequence[str]) -> Sequence[str]:
    """Reverses the given string

    :param s: the string to be reversed
    :return: the reversed string
    """
    return s[::-1]


def count_vowels(s: Iterable[str]) -> int:
    """Counts the number of vowels present in the given object.

    Vowels are the following characters:
    a, e, i, o, u, A, E, I, O, U

    :param s: object containing characters
    :return: number of vowels found
    """
    vowels = "aeiouAEIOU"
    return sum(1 for char in s if char in vowels)


def is_palindrome(s: Iterable[str]) -> bool:
    """Checks if a object containing ordered text is a palindrome.

    A palindrome is a ordered list that doesn't change if the order of it's elements is reversed.

    :param s: ordered text
    :return: `True` if **s** is a palindrome and `False` otherwise

..  seealso::

    You should see also:

    `Wikipedias explanaition on palindromes. <https://en.wikipedia.org/wiki/Palindrome>`_
    """
    s = "".join(char.lower() for char in s if char.isalnum())
    return s == s[::-1]


def find_longest_word(sentence: str) -> int | str:
    """Finds the longest word in a sentance
    
    :param sentence: a sentence containing words
    :return: either length of the longest word as `int` or an empty `str` if the sentence doesn't contain a word.
    """

    words = sentence.split()
    return max(words, key=len) if words else ""


T = TypeVar("T")


def remove_duplicates(lst: Iterable[T]) -> List[T]:
    """Removes duplicate elements from an Iterable Object.
    
    :param lst: an object containing elements
    :return: a List of the same elements but without duplicates.
    """
    return list(dict.fromkeys(lst))

# an Interface
class LEComparable(metaclass=ABCMeta):
    @abstractmethod
    def __le__(self, other: Any) -> bool: ...


Comp = TypeVar("Comp", bound=LEComparable)

#def merge_sorted_lists(list1: List, list2: List) -> List:
def merge_sorted_lists(list1: Sequence[Comp], list2: Sequence[Any]) -> List[Comp|Any]:
    """Merges two sorted lists, so that the Union is sorted too.
    
    :param list1: first sorted list
    :param list2: second sorted list
    :return: a sorted List containing each element of the input lists.
    """
    result = []
    i, j = 0, 0
    while i < len(list1) and j < len(list2):
        if list1[i] <= list2[j]:
            result.append(list1[i])
            i += 1
        else:
            result.append(list2[j])
            j += 1
    result.extend(list1[i:])
    result.extend(list2[j:])
    return result


def flatten_list(nested_list: List[object | List]) -> List:
    """Makes nested lists (aka. multidimensional lists) flat (aka. one dimensional)
    
    :param nested_list: with arbitrary nestednes (aka. dimensionality)
    :return: a flat list with all elements contained in the nested_list.
    """
    flat_list = []
    for item in nested_list:
        if isinstance(item, list):
            flat_list.extend(flatten_list(item))
        else:
            flat_list.append(item)
    return flat_list


def calculate_average(numbers: Collection) -> Number | float:
    """Calculates the average of all elements in numbers.
    
    :param numbers: object containing arbitrary numbers as elements 
    :return: the average, which is the sum of all elements in numbers divided by the number of elements in numbers. Or 0 if numers is empty.
    """
    return sum(numbers) / len(numbers) if numbers else 0


def find_common_elements(list1: Iterable, list2: Iterable) -> List:
    """Basically computes the intersetction of two lists.
    
    :param list1: some list
    :param list2: another list
    :return: a list containing only elements which are in both input lists.
    """
    return list(set(list1) & set(list2))


def rotate_list(lst: List, k: int) -> List:
    """Rotates (aka. rolls) a list for k indices to get.

    roll means: new[(i+k) % len(old)] = old[i]
    
    :param lst: an object containing elements
    :param k: number of roll steps to be performed
    :return: a rolled version of the input list.
    """
    if not lst:
        return lst
    k = k % len(lst)
    return lst[-k:] + lst[:-k]
